/*!
 * venan
 * Copyright(c) 2024 Ivanno VenÃ¢ncio
 * MIT Licensed
 */

import fs from 'fs';
import http from 'http';
import path from 'path';


export class Router {
  constructor() {
    this.routes = {
      GET: {},
      POST: {},
      PUT: {},
      DELETE: {}
    };
  }

  get(path, handler) {
    this.routes.GET[path] = handler;
  }

  post(path, handler) {
    this.routes.POST[path] = handler;
  }

  put(path, handler) {
    this.routes.PUT[path] = handler;
  }

  delete(path, handler) {
    this.routes.DELETE[path] = handler;
  }

  applyRoutes(app) {
    Object.keys(this.routes).forEach(method => {
      Object.keys(this.routes[method]).forEach(route => {
        app.routes[method][route] = this.routes[method][route];
      });
    });
  }
}

export class Venan {
  constructor() {
    this.routes = {
      GET: {},
      POST: {},
      PUT: {},
      DELETE: {}
    };
    this.staticPath = null;
    this.viewEngine = null;
    this.viewsPath = 'views'; // Default path for views
  }

  use(router) {
    router.applyRoutes(this);
  }

  get(path, handler) {
    this.routes.GET[path] = handler;
  }

  post(path, handler) {
    this.routes.POST[path] = handler;
  }
  
  put(path, handler) {
    this.routes.PUT[path] = handler;
  }

  delete(path, handler) {
    this.routes.DELETE[path] = handler;
  }

  serveStatic(directory) {
    this.staticPath = directory;
  }

  setTemplateEngine(viewEngine) {
    this.viewEngine = viewEngine;
  }

  async deliver(res, templateName, data, layoutName = 'main') {
    if (this.viewEngine) {
      this.viewEngine.render(res, templateName, data, layoutName);
    } else {
      throw new Error('View engine not set.');
    }
  }
  

  matchRoute(url, method) {
    const routes = this.routes[method];
    if (!routes) return null;

    const routeKeys = Object.keys(routes);

    for (let route of routeKeys) {
      const routeParts = route.split('/').filter(Boolean);
      const urlParts = url.split('/').filter(Boolean);

      if (routeParts.length !== urlParts.length) continue;

      const params = {};
      let match = true;

      for (let i = 0; i < routeParts.length; i++) {
        if (routeParts[i].startsWith(':')) {
          const paramName = routeParts[i].slice(1);
          params[paramName] = urlParts[i];
        } else if (routeParts[i] !== urlParts[i]) {
          match = false;
          break;
        }
      }

      if (match) {
        return { handler: routes[route], params };
      }
    }

    return null;
  }

  handle(req, res) {
    const { method, url } = req;

        // Adding render to response object 
    res.render = (templateName, data) => this.deliver(res, templateName, data) 

    if (this.staticPath && method === 'GET') {
      const filePath = path.join(this.staticPath, url === '/' ? 'index.html' : url);
      const ext = path.extname(filePath);
      let contentType = 'text/html';

      switch (ext) {
        case '.js':
          contentType = 'application/javascript';
          break;
        case '.css':
          contentType = 'text/css';
          break;
        case '.png':
          contentType = 'image/png';
          break;
        case '.jpg':
        case '.jpeg':
          contentType = 'image/jpeg';
          break;
        case '.gif':
          contentType = 'image/gif';
          break;
        case '.ico':
          contentType = 'image/x-icon';
          break;
        default:
          contentType = 'text/html';
      }

      fs.readFile(filePath, (err, data) => {
        if (err) {
          res.statusCode = 404;
          res.end('Not Found');
        } else {
          res.statusCode = 200;
          res.setHeader('Content-Type', contentType);
          res.end(data);
        }
      });
      return;
    }

    const matchedRoute = this.matchRoute(url, method);

    if (matchedRoute) {
      req.params = matchedRoute.params;
      matchedRoute.handler(req, res);
    } else {
      res.statusCode = 404;
      res.end('Not Found');
    }
  }

  listen(port, callback) {
    const server = http.createServer((req, res) => {
      this.handle(req, res);
    });
    server.listen(port, callback);
    return server;
  }
}
