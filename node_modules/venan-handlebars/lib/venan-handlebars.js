import fs from 'fs';
import Handlebars from 'handlebars';
import path from 'path';

class VenanHandlebars {
  constructor(app, options = {}) {
    this.app = app;
    this.options = options;
    this.viewsPath = options.viewsPath || 'views';

    if (options.helpers) {
      this.registerHelpers(options.helpers);
    }

    if (options.partials) {
      this.registerPartials(options.partials);
    }

    this.app.setTemplateEngine({
      render: this.render.bind(this)
    }, { viewsPath: this.viewsPath });
  }

  registerHelpers(helpers) {
    Object.entries(helpers).forEach(([name, fn]) => {
      Handlebars.registerHelper(name, fn);
    });
  }

  registerPartials(partialsDir) {
    const partialFiles = fs.readdirSync(partialsDir);

    partialFiles.forEach(file => {
      const partialName = path.basename(file, path.extname(file));
      const partialContent = fs.readFileSync(path.join(partialsDir, file), 'utf8');
      Handlebars.registerPartial(partialName, partialContent);
    });
  }

  render(res, templateName, data, layoutName = layoutName ? layoutName : 'main') {
    const templateFilePath = path.join(this.viewsPath, `${templateName}.handlebars`);
    const layoutFilePath = path.join(this.viewsPath, 'layouts', `${layoutName}.handlebars`);

    const templateContent = fs.readFileSync(templateFilePath, 'utf8');
    const layoutContent = fs.existsSync(layoutFilePath)
      ? fs.readFileSync(layoutFilePath, 'utf8')
      : null;

    const template = Handlebars.compile(templateContent);
    const body = template(data);

    let output;
    if (layoutContent) {
      const layout = Handlebars.compile(layoutContent);
      output = layout({ ...data, body });
    } else {
      output = body;
    }

    res.setHeader('Content-Type', 'text/html');
    res.end(output);
  }
}

export default VenanHandlebars;
